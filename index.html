<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Meine Bibliothek</title>
  
  <style>
    /* Grundlegende Stile f√ºr die Seite */
    body {
	  font-family: sans-serif;
	  background: #523f31;
	  margin: 2rem;
	  padding-top: 220px; /* f√ºr festen Header */
}
    /* Stile f√ºr die Buttons */
#import-btn, #edit-mode-btn, #add-manual-btn,
#save-btn, #load-btn {
  background-color: #4a3b2f; /* Hintergrundfarbe */
  color: white; /* Textfarbe */
  border: none; /* Kein Rahmen */
  padding: 0.5rem 0.8rem; /* Innenabst√§nde */
  font-size: 0.8rem;
  cursor: pointer; /* Zeiger-Cursor */
  border-radius: 5px; /* Abgerundete Ecken */
  margin-bottom: 1rem; /* Abstand nach unten */
  margin-right: 0.5rem; /* Abstand nach rechts */
}
/* Hover-Effekt f√ºr die Buttons */
#import-btn:hover, #edit-mode-btn:hover, #add-manual-btn:hover,
#save-btn:hover, #load-btn:hover {
  background-color: #a15518; /* Dunklere Farbe beim Hover */
}


#filter-options label {
  display: inline-flex;
  flex-direction: column;
  margin-right: 1rem;
  font-size: 0.9rem;
}

/* Fixiere den oberen Bereich mit den Buttons */
#header {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    background-color: #f7e2b7; /* Farbe f√ºr den Header */
    z-index: 1000; /* Damit der Header immer oben bleibt */
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.8); /* Optional: Ein leichter Schatten f√ºr den Header */
    padding: 5px 10px; /* Optional: Falls du Padding im Header m√∂chtest */
}


    /* Stile f√ºr die Buchdarstellung */
    .book {
      border: 1px solid #ccc; /* Rahmen um jedes Buch */
      padding: 1rem;
      margin-bottom: 1rem; /* Abstand nach unten */
      background: #fff; /* Hintergrundfarbe */
      display: flex; /* Flexbox f√ºr Layout */
      align-items: flex-start; /* Ausrichtung der Elemente */
      gap: 1rem; /* Abstand zwischen den Elementen */
    }
    .book img { 
      height: 140px; /* Feste H√∂he f√ºr das Cover */
    }
    .book-info { 
      flex: 1; /* Damit der Text den restlichen Platz einnimmt */
    }
    .book-title { 
      font-size: 1.2rem; 
      font-weight: bold; /* Titel fett */
    }
    /* Abstand zwischen Autoren und ISBN */
    .book-info .authors { 
      margin-bottom: 0.5rem; 
    }
    /* Filter-Button-Stile */
.filter-bar button {
  margin: 0.2rem; /* Abstand zwischen den Buttons */
  padding: 0.5rem 0.4rem;
  border: 1px solid #ccc; /* Rahmen um die Buttons */
  background-color: #4a3b2f; /* Hintergrundfarbe */
  color: white; /* Textfarbe */
  cursor: pointer; /* Zeiger-Cursor */
  border-radius: 3px; /* Abgerundete Ecken */
  transition: background-color 0.2s, transform 0.2s;
}

/* Hover-Effekt f√ºr Filterbuttons */
.filter-bar button:hover {
  background-color: #1a7c22; /* etwas hellerer Braunton */
  transform: scale(1.1); /* leichtes Vergr√∂√üern beim Hovern */
}

/* Aktiver Button (aktive Filter) */
.filter-bar button.active {
  background-color: #21942a; /* Gr√ºn f√ºr aktive Filter */
  color: white;
}

/* Zeile f√ºr Dropdowns und Suchfeld */
.filter-row {
  display: flex;
  justify-content: flex-start; /* Elemente links ausrichten */
  align-items: center;
  gap: 2rem;
  margin: 0.5rem 0 0;
  flex-wrap: wrap;
}

/* Wrapper f√ºr das Suchfeld */
.search-wrapper {
  position: relative;
  flex-grow: 0; /* Verhindert, dass es den gesamten Raum einnimmt */
  max-width: 150px; /* Maximale Breite f√ºr das Suchfeld */
  padding-right: 20px; /* Abstand zum rechten Rand */
  margin-left: auto; /* Schiebt das Suchfeld nach rechts */
}

/* Suchfeld */
#search-input {
  width: 100%; /* Nimmt die volle Breite des Wrappers ein */
  padding: 0.4rem 2.5rem 0.4rem 0.5rem; /* Platz f√ºr das X-Symbol */
  border: 1px solid #aaa;
  border-radius: 5px;
  font-size: 0.9rem;
  background-color: #fff;
  box-sizing: border-box; /* Damit Padding nicht zur Breite hinzukommt */   
}

/* L√∂schen-Icon f√ºr Suche */
#clear-search {
  position: absolute;
  right: 30px; /* Das X bleibt im Feld, mit etwas Abstand */
  top: 50%;
  transform: translateY(-50%);
  font-weight: bold;
  color: #888;
  cursor: pointer;
  user-select: none;
  font-size: 1.2rem;
}

/* Dropdown-Container links */
.dropdowns {
  display: flex;
  gap: 0.5rem;
}

/* Styling f√ºr Dropdowns */
.dropdowns select {
  padding: 0.3rem 1.5rem 0.3rem 0.5rem;
  font-size: 0.9rem;
  border-radius: 5px;
  border: 1px solid #aaa;
  background-color: #fff;
  background-image: url("data:image/svg+xml;charset=UTF-8,%3Csvg width='10' height='6' viewBox='0 0 10 6' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M0 0l5 6 5-6z' fill='%23666'/%3E%3C/svg%3E");
  background-repeat: no-repeat;
  background-position: right 0.6rem center;
  background-size: 0.6rem;
  appearance: none;
  min-width: 120px;
}



  </style>
</head>
<body>
<div id="header">
<!-- Haupt√ºberschrift der Seite -->
<h3>üìö Meine Bibliothek</h3>
<link rel="icon" href="favicon.png" type="image/png">


<!-- A-Z Filterleiste -->
<div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 1rem;">
  <div class="filter-bar" id="filter-bar" style="flex-grow: 1;"></div>
</div>

<!-- Kategorie, Genre und Suche -->
  <div class="filter-row">
  <div class="dropdowns">
    <select id="category-select">
      <option value="">Kategorie</option>
    </select>
    <select id="genre-select">
      <option value="">Genre</option>
    </select>
  </div>
  <div class="search-wrapper">
  <input type="text" id="search-input" placeholder="üîç Suchen..." />
  <span id="clear-search">√ó</span>
</div>

</div>

  
<div id="genre-buttons" style="display: flex; gap: 0.5rem; flex-wrap: wrap; margin-bottom: 1rem;"></div>

<!-- Buttons zum Importieren und Bearbeiten -->
<button id="import-btn" onclick="document.getElementById('file-input').click()">üì• B√ºcher importieren</button>
<button id="add-manual-btn" onclick="newBookEntry()">‚ûï Neuer Eintrag</button>
<button id="edit-mode-btn" onclick="toggleEditMode()">‚úèÔ∏è Bearbeiten</button>
<button id="load-btn" onclick="document.getElementById('load-file').click()">üìÇ Bibliothek laden</button>
<button id="save-btn" onclick="saveLibrary()">üìÖ Bibliothek speichern</button>

<!-- Unsichtbare Inputs -->
  <input type="file" id="file-input" accept=".epub" multiple style="display:none">
  <input type="file" id="load-file" accept=".json" style="display:none">
</div>


<!-- Bereich zum Anzeigen der B√ºcher -->
<div id="library"></div>

<!-- Bearbeitungsformular f√ºr B√ºcher -->
<dialog id="edit-dialog">
  <form method="dialog" id="edit-form" style="display:flex; flex-direction:column; gap:0.5rem; min-width: 300px;">
  <h3>Buch bearbeiten oder hinzuf√ºgen</h3>
  
  <!-- Unsichtbares Feld f√ºr die Index-Referenz -->
  <input type="hidden" id="edit-index">
  
  <!-- Eingabefelder f√ºr die Buchdaten -->
  <label>Titel: <input type="text" id="edit-title" required></label>
  <label>Autor(en) (Nachname, Vorname ‚Äì Semikolon-getrennt): <input type="text" id="edit-authors" required></label>
  <label>Serie: <input type="text" id="edit-series"></label>
  <label>Band: <input type="text" id="edit-volume"></label>
  <label>Ver√∂ffentlicht: <input type="text" id="edit-publishedDate"></label>
  <label>ISBN: <input type="text" id="edit-isbn"></label>
  <label>Kategorie: <input type="text" id="edit-category" list="categorySuggestions"></label>
  <label>Genre: <input type="text" id="edit-genre" list="genreSuggestions"></label>
  <label>Beschreibung: <textarea id="edit-description" rows="4"></textarea></label>
  <label>Seitenzahl: <input type="text" id="edit-pageCount"></label>
  <label>Cover-URL: <input type="text" id="edit-thumbnail"></label>
  <label><input type="checkbox" id="edit-read"> üìñ Gelesen</label>

  <!-- Bewertungsfeld -->
  <label for="edit-rating">Bewertung (1-5 Sterne):</label>
  <select id="edit-rating" name="edit-rating">
    <option value="">Keine Bewertung</option>
    <option value="1">‚≠ê</option>
    <option value="2">‚≠ê‚≠ê</option>
    <option value="3">‚≠ê‚≠ê‚≠ê</option>
    <option value="4">‚≠ê‚≠ê‚≠ê‚≠ê</option>
    <option value="5">‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</option>
  </select>

  <!-- Men√º mit Buttons f√ºr Speichern und Abbrechen -->
<menu style="display:flex; justify-content: flex-end; gap:1rem; margin-top:1rem;">
  <!-- Speichern-Button -->
  <button type="submit">üìÖ Speichern</button>
  <!-- Abbrechen-Button, schlie√üt das Bearbeitungsdialog -->
  <button type="reset" onclick="document.getElementById('edit-dialog').close()">Abbrechen</button>
</menu>
</form>
</dialog>

<!-- Datalist f√ºr die Kategorievorschl√§ge -->
<datalist id="categorySuggestions"></datalist>

<!-- Datalist f√ºr die Genre-Vorschl√§ge -->
<datalist id="genreSuggestions"></datalist>

<!-- Einbindung von JSZip (Bibliothek f√ºr ZIP-Dateien) -->
<script src="https://unpkg.com/jszip/dist/jszip.min.js"></script>

<script>

// Initialisierung der Bibliothek aus dem lokalen Speicher oder einem leeren Array
let books = [];

// Genre Map definieren

const genreMap = {
  "Belletristik": ["Erotik", "Fantasy", "Frauen, Liebesroman", "Historisch", "Horror", "Humor", "Kinder, Jugend", "Klassiker", "Krimi & Thriller", "Mystery", "Romane & Erz√§hlungen", "Science Fiction"],
  "Sachbuch": ["Biografien & Erinnerungen", "Geschichte", "Gesundheit & Medizin", "Kunst", "Mathematik", "Naturwissenschaft", "Philosophie", "Politik", "Reisen"],
};

// Initialisierung von Variablen
let editMode = false; // Bearbeitungsmodus ein/aus
let activeFilters = []; // Aktive Filter
let isCreatingNew = false; // Flag, ob ein neues Buch erstellt wird
let filterStatus = 'all'; // Filter-Status: 'all', 'read', 'unread'
let selectedCategories = [];
let selectedGenres = [];
const knownCategories = new Set(); // Bekannte Kategorien (Set f√ºr Duplikate)
const knownGenres = new Set(); // Bekannte Genres (Set f√ºr Duplikate)

// Funktion, um Namen zu normalisieren (z.B. Trimmen und Trennzeichen bereinigen)
function normalizeName(name) {
  return name
    .trim() // Entfernt f√ºhrende und nachfolgende Leerzeichen
    .replace(/,+/g, ',') // Entfernt mehrfaches Komma
    .replace(/\s*,\s*/g, ', ') // Bereinigt Leerzeichen vor/nach Komma
    .replace(/\s*;\s*/g, '; ') // Bereinigt Leerzeichen vor/nach Semikolon
    .replace(/^;+|;+$|^,+|,+$/g, '') // Entfernt f√ºhrende/abschlie√üende Trennzeichen
    .split(';') // Trennt nach Semikolon
    .map(part => part.trim()) // Entfernt f√ºhrende/nachfolgende Leerzeichen
    .filter(Boolean) // Entfernt leere Teile
    .join('; '); // Verbindet die Teile wieder mit Semikolon
}

// Funktion, um den ersten Buchstaben eines Namens zu normalisieren (mit Gro√übuchstaben)
function normalizeFirstLetter(name) {
  return normalizeName(name).charAt(0).toUpperCase().normalize("NFD").replace(/[\u0300-\u036f]/g, '');
}

// Event Listener f√ºr das Bearbeitungsformular (Speichern eines Buches)
document.getElementById("edit-form").addEventListener("submit", () => {
  // Index des bearbeiteten Buches (falls vorhanden)
  const index = document.getElementById("edit-index").value;
  
  // Rohdaten der Autoren
  const authorsRaw = document.getElementById("edit-authors").value;
  
  // Neues Buchobjekt mit den Werten aus dem Formular
  const book = {
    title: document.getElementById("edit-title").value.trim(),
    authors: authorsRaw
      .split(';') // Trennt nach Semikolon
      .map(a => normalizeName(a.trim())) // Normalisiert Autoren-Namen
      .filter(Boolean), // Entfernt leere Werte
    series: document.getElementById("edit-series").value.trim(),
  volume: document.getElementById("edit-volume").value.trim(),
  publishedDate: document.getElementById("edit-publishedDate").value.trim(),
  isbn: document.getElementById("edit-isbn").value.trim(),
  category: document.getElementById("edit-category").value.trim(),
  genre: document.getElementById("edit-genre").value.trim(),
  description: document.getElementById("edit-description").value.trim(),
  thumbnail: document.getElementById("edit-thumbnail").value.trim(),
  read: document.getElementById("edit-read").checked,
  rating: document.getElementById("edit-rating").value || null,
  pageCount: document.getElementById("edit-pageCount").value.trim() // Seitenzahl hinzuf√ºgen
};

  // Wenn der Index gesetzt ist und kein neues Buch erstellt wird, wird das Buch aktualisiert
  if (index !== '' && !isCreatingNew) library[+index] = { ...library[+index], ...book };
  else library.push(book); // Ansonsten wird das Buch zur Bibliothek hinzugef√ºgt

  // Speichern der Bibliothek im lokalen Speicher
  localStorage.setItem("epubLibrary", JSON.stringify(books));

  // Schlie√üen des Dialogs
  document.getElementById("edit-dialog").close();
  
  // Bibliothek neu rendern
  renderLibrary();
});

  // Dropdown dynamisch
  
document.getElementById("edit-category").addEventListener("input", () => {
  const selectedCategory = document.getElementById("edit-category").value;
  const genreList = document.getElementById("genreSuggestions");

  genreList.innerHTML = ''; // alte Vorschl√§ge l√∂schen

  const genres = genreMap[selectedCategory] || [];

  genres.forEach(genre => {
    const option = document.createElement("option");
    option.value = genre;
    genreList.appendChild(option);
  });

  // Genre zur√ºcksetzen, wenn es zur neuen Kategorie nicht passt
  if (!genres.includes(document.getElementById("edit-genre").value)) {
    document.getElementById("edit-genre").value = '';
  }
});

// Funktion zum Rendern der Filterleiste
function renderFilterBar() {
  const filterBar = document.getElementById("filter-bar");
  filterBar.innerHTML = ''; // Zun√§chst alle bestehenden Filter-Buttons entfernen

  // Button f√ºr "Alle" B√ºcher
  const allBtn = document.createElement("button");
  allBtn.textContent = "üìö Alle";
  allBtn.classList.toggle("active", filterStatus === 'all'); // Aktivieren des Buttons, wenn der Filter 'all' ist
  allBtn.onclick = () => {
  filterStatus = 'all';
  renderLibrary();
  renderFilterBar();
}; // Event-Handler f√ºr den Klick
  filterBar.appendChild(allBtn);

  // Button f√ºr "Gelesene" B√ºcher
  const readBtn = document.createElement("button");
  readBtn.textContent = "üìñ Gelesen";
  readBtn.classList.toggle("active", filterStatus === 'read'); // Aktivieren des Buttons, wenn der Filter 'read' ist
  readBtn.onclick = () => {
  filterStatus = 'read';
  renderLibrary();
  renderFilterBar(); // <<< Wichtig!
}; // Event-Handler f√ºr den Klick
  filterBar.appendChild(readBtn);

  // Button f√ºr "Neue" B√ºcher
  const unreadBtn = document.createElement("button");
  unreadBtn.textContent = "üÜï Neu";
  unreadBtn.classList.toggle("active", filterStatus === 'unread'); // Aktivieren des Buttons, wenn der Filter 'unread' ist
  unreadBtn.onclick = () => {
  filterStatus = 'unread';
  renderLibrary();
  renderFilterBar();
}; // Event-Handler f√ºr den Klick
  filterBar.appendChild(unreadBtn);


 // Buchstaben-Filterbuttons A-Z
  // Funktion zur Normalisierung der Buchstaben (einschlie√ülich Umlaute)
  const normalizeCharacter = (char) => {
    // Zuordnung von Umlauten zu normalen Buchstaben
    const umlautMap = {
      '√Ñ': 'A',
      '√ñ': 'O',
      '√ú': 'U',
      '√§': 'a',
      '√∂': 'o',
      '√º': 'u',
      '√ü': 'ss'
    };
    // R√ºckgabe des normalisierten Zeichens oder des Originalzeichens, wenn keine Umwandlung erforderlich ist
    return umlautMap[char] || char;
  };

  // A-Z Filter-Buttons erzeugen (f√ºr Buchstaben A-Z)
  for (let i = 65; i <= 90; i++) {
    const char = String.fromCharCode(i); // A bis Z
    const btn = document.createElement("button");
    btn.textContent = char; // Setzt den Text des Buttons auf den Buchstaben

    // Event-Handler f√ºr den Klick auf den Button
    btn.onclick = () => {
      // Wenn der Buchstabe bereits aktiv ist, entfernen wir ihn aus den Filtern
      if (activeFilters.includes(char)) {
        activeFilters = activeFilters.filter(l => l !== char);
      } else {
        // Ansonsten f√ºgen wir ihn zu den aktiven Filtern hinzu
        activeFilters.push(char);
      }
      // Nach der Filter√§nderung die Bibliothek neu rendern
      renderFilterBar();
	  renderLibrary();
    };

    // Wenn der Buchstabe bereits im Filter aktiv ist, wird der Button visuell markiert
    if (activeFilters.includes(char)) {
      btn.classList.add("active");
	}
    // Der Button wird zur Filterleiste hinzugef√ºgt
    filterBar.appendChild(btn);
  }

}

function renderLibrary() {
  renderFilterBar(); // Filterleiste neu rendern (z.B. aktivierte Buchstaben)
  const libraryDiv = document.getElementById("library");
  libraryDiv.innerHTML = ''; // Anzeige leeren
  let books = [...books]; // Arbeitskopie der Bibliothek

  // Kategorie-Filter anwenden
  if (selectedCategories.length > 0) {
    books = books.filter(book =>
      selectedCategories.includes(book.category)
    );
  }

  // Freitextsuche anwenden
  const searchTerm = document.getElementById("search-input").value.trim().toLowerCase();
  if (searchTerm) {
    books = books.filter(book =>
      (book.title || '').toLowerCase().includes(searchTerm) ||
      (book.authors || []).join('; ').toLowerCase().includes(searchTerm) ||
      (book.series || '').toLowerCase().includes(searchTerm)
    );
  }

  // Filter "Gelesen" / "Ungelesen" anwenden
  if (filterStatus === 'read') {
    books = books.filter(book => book.read === true);
  } else if (filterStatus === 'unread') {
    books = books.filter(book => book.read !== true);
  }

  // Buchstabenfilter A‚ÄìZ anwenden
  if (activeFilters.length > 0) {
    books = books.filter(book =>
      (book.authors || []).some(author =>
        activeFilters.includes(normalizeFirstLetter(author))
      )
    );
  }

  // Sortierung anwenden
  books.sort((a, b) => {
    const aStr = `${normalizeName(a.authors?.[0] || '')} - ${a.series || ''} - ${a.volume || ''} - ${a.title}`;
    const bStr = `${normalizeName(b.authors?.[0] || '')} - ${b.series || ''} - ${b.volume || ''} - ${b.title}`;
    return aStr.localeCompare(bStr, 'de'); // Sortierung nach deutschem Alphabet
  });

  // Ausgabe jedes Buchs als HTML-Block
  books.forEach(book => {
    const index = library.indexOf(book); // Position f√ºr Bearbeiten/L√∂schen
    const div = document.createElement('div');
    div.className = 'book';
    div.style.backgroundColor = "#f7e2b7";
    div.style.padding = "10px";
    div.style.marginBottom = "10px";
    div.style.borderRadius = "8px";
    div.style.boxShadow = "0 2px 4px rgba(0, 0, 0, 0.1)";

    div.innerHTML = `
      <img src="${book.thumbnail || ''}" alt="Cover">
      <div class="book-info">
        <div class="book-title">
          ${book.title}
          ${editMode ? `<button onclick="editBook(${index})" style="margin-left: 1rem;">‚úèÔ∏è</button>` : ''}
        </div>
        <div>${(book.authors || []).map(normalizeName).join('; ')}</div>
        ${book.series ? `<div><b>Serie:</b> ${book.series}</div>` : ''}
        ${book.volume ? `<div><b>Band:</b> ${book.volume}</div>` : ''}
        ${book.category ? `<div><b>Kategorie:</b> ${book.category}</div>` : ''}
        ${book.genre ? `<div><b>Genre:</b> ${book.genre}</div>` : ''}
        <div><b>ISBN:</b> ${book.isbn || 'Unbekannt'}</div>
        <div><b>Ver√∂ffentlicht:</b> ${book.publishedDate || 'Unbekannt'}</div>
        <div><b>Seitenanzahl:</b> ${book.pageCount || 'Unbekannt'}</div>
        <div><b>Gelesen:</b> ${book.read ? 'Ja' : 'Nein'}</div>
        ${book.rating ? `<div><b>Bewertung:</b> ${'‚òÖ'.repeat(book.rating)}${'‚òÜ'.repeat(5 - book.rating)}</div>` : ''}
        <div>${book.description || ''}</div>
        <button onclick="confirmRemoveBook(${index})">üóëÔ∏è Buch l√∂schen</button>
      </div>`;
    libraryDiv.appendChild(div);
  });
}


// Bearbeitungsmodus umschalten
function toggleEditMode() {
  editMode = !editMode;
  document.getElementById("edit-mode-btn").textContent = editMode ? "‚úÖ Bearbeiten beenden" : "‚úèÔ∏è Bearbeiten";
  renderLibrary(); // Anzeige neu laden
}

// Buch l√∂schen und neu speichern
function removeBook(index) {
  library.splice(index, 1); // Eintrag aus Array entfernen
  localStorage.setItem("epubLibrary", JSON.stringify(library)); // neu speichern
  renderLibrary(); // Anzeige aktualisieren
}

// Bibliothek als JSON exportieren
function saveLibrary() {
  const blob = new Blob([JSON.stringify(library, null, 2)], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = "meine_bibliothek.json";
  a.click();
  URL.revokeObjectURL(url); // Speicher wieder freigeben
}

// Neuer Bucheintrag: Formular vorbereiten & √∂ffnen
function newBookEntry() {
  isCreatingNew = true;
  document.getElementById("edit-form").reset();
  document.getElementById("edit-category").value = '';
  document.getElementById("edit-genre").value = '';
  document.getElementById("edit-index").value = '';
  document.getElementById("edit-read").checked = false;
  document.getElementById("edit-dialog").showModal();
}

function editBook(index) {
  
  const book = library[index]; // Buch aus der Bibliothek holen
  isCreatingNew = false; // Signalisieren, dass es sich um Bearbeiten handelt

  // Formulare mit vorhandenen Buchdaten f√ºllen
  document.getElementById("edit-index").value = index;
  document.getElementById("edit-title").value = book.title || '';
  document.getElementById("edit-authors").value = (book.authors || []).join('; ');
  document.getElementById("edit-series").value = book.series || '';
  document.getElementById("edit-volume").value = book.volume || '';
  document.getElementById("edit-isbn").value = book.isbn || '';
  document.getElementById("edit-category").value = book.category || '';
  document.getElementById("edit-genre").value = book.genre || '';
  document.getElementById("edit-publishedDate").value = book.publishedDate || '';
  document.getElementById("edit-description").value = book.description || '';
  document.getElementById("edit-thumbnail").value = book.thumbnail || '';
  document.getElementById("edit-read").checked = book.read || false;
  document.getElementById("edit-rating").value = book.rating || ''; // Bewertung, falls vorhanden
  document.getElementById("edit-pageCount").value = book.pageCount || 'Unbekannt';
  document.getElementById("edit-dialog").showModal(); // Bearbeitungsdialog anzeigen
  

  // Vorschlagslisten f√ºr Kategorie und Genre erzeugen
const categories = [...new Set(library.map(b => b.category).filter(Boolean))].sort();
const allGenres = [...new Set(library.map(b => b.genre).filter(Boolean))].sort();

const categoryList = document.getElementById("categorySuggestions");
const genreList = document.getElementById("genreSuggestions");

// Alte Vorschl√§ge entfernen
categoryList.innerHTML = '';
genreList.innerHTML = '';

// Neue Kategorien einf√ºgen
categories.forEach(cat => {
  const option = document.createElement("option");
  option.value = cat;
  categoryList.appendChild(option);
});

// Neue Genres einf√ºgen
allGenres.forEach(genre => {
  const option = document.createElement("option");
  option.value = genre;
  genreList.appendChild(option);
});


document.getElementById("edit-dialog").showModal(); // Sicherstellen, dass der Dialog ge√∂ffnet ist
}

// Bei Datei-Upload: alle ausgew√§hlten Dateien verarbeiten
document.getElementById("file-input").addEventListener("change", async (e) => {
  const files = Array.from(e.target.files);
  for (const file of files) {
    await processFile(file); // Datei verarbeiten (inkl. Google Books API)
  }
  localStorage.setItem("epubLibrary", JSON.stringify(library)); // Bibliothek speichern
  renderLibrary(); // Bibliothek neu anzeigen
});

// JSON-Datei laden und Bibliothek ersetzen
document.getElementById("load-file").addEventListener("change", async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const text = await file.text();
  try {
    const json = JSON.parse(text);
    if (Array.isArray(json)) {
      library = json; // Neue Bibliothek √ºbernehmen
      localStorage.setItem("epubLibrary", JSON.stringify(library)); // Speichern
      renderLibrary(); // Anzeige aktualisieren
    } else {
      alert("Ung√ºltiges Format");
    }
  } catch (err) {
    alert("Fehler beim Laden der Datei");
  }
});

// Autoren ins Format "Nachname, Vorname" umwandeln
function formatAuthors(authors) {
  return authors.map(name => {
    name = name.trim();

    // Wenn Komma vorhanden ‚Üí bereits richtig formatiert
    if (name.includes(',')) {
      const [last, first] = name.split(',').map(s => s.trim());
      return `${last}, ${first}`;
    } else {
      // Kein Komma: Wir nehmen an "Vorname Nachname"
      const parts = name.split(/\s+/);
      if (parts.length >= 2) {
        const firstName = parts.slice(0, -1).join(' ');
        const lastName = parts.slice(-1)[0];
        return `${lastName}, ${firstName}`;
      }
      return name; // Einzelwort (z.‚ÄØB. "Goethe") bleibt unver√§ndert
    }
  });
}

function confirmRemoveBook(index) {
  const book = library[index];
  const title = book.title || 'dieses Buch';
  if (confirm(`M√∂chtest du "${title}" wirklich l√∂schen?`)) {
    removeBook(index); // L√∂schen, wenn best√§tigt
  }
}

// Bei Texteingabe ins Suchfeld wird sofort neu gerendert
document.getElementById("search-input").addEventListener("input", () => {
  renderLibrary();
});

// Hilfsfunktion: ISBN-10 in ISBN-13 konvertieren
function convertISBN10to13(isbn10) {
  const core = "978" + isbn10.substring(0, 9); // Pr√§fix 978 + erste 9 Stellen
  let sum = 0;
  for (let i = 0; i < core.length; i++) {
    sum += parseInt(core[i], 10) * (i % 2 === 0 ? 1 : 3); // Gewichtung: abwechselnd 1 und 3
  }
  const checkDigit = (10 - (sum % 10)) % 10; // Pr√ºfziffer berechnen
  return core + checkDigit; // Ergebnis ist g√ºltige ISBN-13
}

// Hauptfunktion zum Verarbeiten einer einzelnen .epub-Datei
async function processFile(file) {
  const zip = await JSZip.loadAsync(file); // .epub als ZIP laden
  const container = await zip.file("META-INF/container.xml").async("string");
  const parser = new DOMParser();
  const containerDoc = parser.parseFromString(container, "application/xml");
  const rootfilePath = containerDoc.querySelector("rootfile")?.getAttribute("full-path");
  if (!rootfilePath) return;

  const contentOpf = await zip.file(rootfilePath).async("string");
  const opfDoc = parser.parseFromString(contentOpf, "application/xml");

  // Titel extrahieren (Fallback: Dateiname ohne .epub)
  let title = opfDoc.querySelector("metadata > title")?.textContent || file.name.replace(/\.epub$/i, '');

  // Alle Autoren als Array holen
  let authors = Array.from(opfDoc.querySelectorAll("metadata > creator")).map(el => el.textContent);

  // M√∂gliche ISBNs suchen
  let rawIsbn = Array.from(opfDoc.querySelectorAll("identifier"))
    .map(el => el.textContent)
    .find(id => id.replace(/[^0-9X]/gi, "").length >= 10) || "";

  // Nur Ziffern + evtl. 'X' behalten
  let digitsOnly = rawIsbn.replace(/[^0-9X]/gi, '');

  // ISBN-10 zu ISBN-13 konvertieren
  if (digitsOnly.length === 10 && !digitsOnly.startsWith("978")) {
    digitsOnly = convertISBN10to13(digitsOnly);
  }

  // Jetzt ist die ISBN bereinigt und API-tauglich
  const cleanIsbn = digitsOnly;

  // Autoren ins "Nachname, Vorname"-Format bringen
  authors = formatAuthors(authors);

  // Vorl√§ufiges Buchobjekt anlegen
  const book = {
    title,
    authors: formatAuthors(authors),
    isbn: cleanIsbn, // bereinigte ISBN verwenden
    series: "",
    volume: "",
    publishedDate: "",
    description: "",
    thumbnail: "",
    read: false
  };

  // Google Books API abfragen
  try {
    const response = await fetch(`https://www.googleapis.com/books/v1/volumes?q=isbn:${cleanIsbn}`);
    const data = await response.json();
    const info = data.items?.[0]?.volumeInfo;
    if (info) {
      // Metadaten von Google erg√§nzen
      book.title = info.title || book.title;
      book.authors = formatAuthors(info.authors || book.authors);
      book.publishedDate = info.publishedDate || "";
      book.description = info.description || "";
      book.thumbnail = info.imageLinks?.thumbnail?.replace("http:", "https:") || "";

      // Statt Kategorie/Genre: Seitenzahl erg√§nzen
      if (info.pageCount) {
        book.pageCount = info.pageCount || "";
      } else {
        book.pageCount = "Unbekannt";
      }
    }
  } catch (err) {
    console.error("Fehler bei der Google Books API:", err); // Fehler-Log
  }

  library.push(book); // Buch zur Bibliothek hinzuf√ºgen
}

// Kategorie-Buttons erzeugen
const categoryButtonsContainer = document.getElementById("category-select");
categoryButtonsContainer.innerHTML = ''; // Leeren

Object.keys(genreMap).forEach(category => {
  const btn = document.createElement("button");
  btn.textContent = category;
  btn.className = "filter-btn";
  if (selectedCategories.includes(category)) btn.classList.add("active");

  btn.onclick = () => {
    // Toggle-Auswahl
    if (selectedCategories.includes(category)) {
      selectedCategories = selectedCategories.filter(c => c !== category);
    } else {
      selectedCategories = [category]; // Nur eine Kategorie aktiv
    }
    selectedGenres = []; // Reset Genre-Auswahl
    renderLibrary(); // Neu rendern
  };

  categoryButtonsContainer.appendChild(btn);
});



// Event Listener f√ºr das √Ñndern der Kategorie
document.getElementById("category-select").addEventListener("change", function() {
  const selectedCategory = this.value;
  selectedCategories = selectedCategory ? [selectedCategory] : []; // Nur eine Kategorie aktiv
  populateGenreDropdown(selectedCategory); // Genre-Dropdown bef√ºllen
  renderLibrary(); // Bibliothek neu rendern, um die Filter anzuwenden
});

// Event Listener f√ºr die Genre-Auswahl
document.getElementById("genre-select").addEventListener("change", function() {
  const selectedGenre = this.value;
  if (selectedGenre) {
    selectedGenres = [selectedGenre]; // Nur ein Genre aktiv
  } else {
    selectedGenres = []; // Kein Genre aktiviert
  }
  renderLibrary(); // Bibliothek neu rendern
});

// Funktion zum Bef√ºllen der Kategorie- und Genre-Dropdowns
function populateCategoryAndGenreDropdowns() {
  const categorySelect = document.getElementById("category-select");
  const genreSelect = document.getElementById("genre-select");

  // Leere die Dropdowns, um sicherzustellen, dass keine alten Optionen vorhanden sind
  categorySelect.innerHTML = '<option value="">Kategorie</option>';
  genreSelect.innerHTML = '<option value="">Genre</option>';

  // Kategorien in das Dropdown einf√ºgen
  Object.keys(genreMap).forEach(category => {
    const option = document.createElement("option");
    option.value = category;
    option.textContent = category;
    categorySelect.appendChild(option);
  });

  // Genre-Optionen in das Dropdown einf√ºgen, basierend auf der ersten Kategorie
  if (selectedCategories.length > 0) {
    const firstCategory = selectedCategories[0]; // Annahme: Eine Kategorie ist ausgew√§hlt
    populateGenreDropdown(firstCategory);
  }
}

 
// Genre-Button wird dynamisch gef√ºllt
function populateGenreDropdown(selectedCategory) {
  const genreSelect = document.getElementById("genre-select");
  genreSelect.innerHTML = '<option value="">Genre</option>';

  if (!selectedCategory || !genreMap[selectedCategory]) return;

  genreMap[selectedCategory].forEach(genre => {
    const option = document.createElement("option");
    option.value = genre;
    option.textContent = genre;
    genreSelect.appendChild(option);
  });
}


// Funktion zum Rendern der Bibliothek unter Ber√ºcksichtigung der Filter
function renderLibrary() {
  const libraryDiv = document.getElementById("library");
  libraryDiv.innerHTML = ''; // Anzeige leeren
  let filteredBooks = [...books]; // Arbeitskopie der Bibliothek

  // Freitextsuche
  const searchTerm = document.getElementById("search-input").value.trim().toLowerCase();
  if (searchTerm) {
    books = books.filter(book =>
      (book.title || '').toLowerCase().includes(searchTerm) ||
      (book.authors || []).join('; ').toLowerCase().includes(searchTerm) ||
      (book.series || '').toLowerCase().includes(searchTerm)
    );
  }

  // Filter "Gelesen" / "Ungelesen"
  if (filterStatus === 'read') {
    books = books.filter(book => book.read === true);
  } else if (filterStatus === 'unread') {
    books = books.filter(book => book.read !== true);
  }

  // Buchstabenfilter A‚ÄìZ
  if (activeFilters.length > 0) {
    books = books.filter(book =>
      (book.authors || []).some(author =>
        activeFilters.includes(normalizeFirstLetter(author))
      )
    );
  }

  // Kategorie-Filter anwenden
  if (selectedCategories.length > 0) {
    books = books.filter(book =>
      selectedCategories.includes(book.category)
    );
  }

  // Genre-Filter anwenden
if (selectedGenres.length > 0) {
  books = books.filter(book =>
    selectedGenres.some(genre => {
      return book.genre && book.genre.includes(genre); // Oder √ºberpr√ºfe, ob book.genre ein Array ist
    })
  );
}

  // Sortierung: AutorNachname ‚Äì Serie ‚Äì Band ‚Äì Titel
  books.sort((a, b) => {
    const aStr = `${normalizeName(a.authors?.[0] || '')} - ${a.series || ''} - ${a.volume || ''} - ${a.title}`;
    const bStr = `${normalizeName(b.authors?.[0] || '')} - ${b.series || ''} - ${b.volume || ''} - ${b.title}`;
    return aStr.localeCompare(bStr, 'de'); // Sortierung nach deutschem Alphabet
  });

  // Ausgabe jedes Buchs als HTML-Block
  books.forEach(book => {
    const index = books.indexOf(book); // Position f√ºr Bearbeiten/L√∂schen
    const div = document.createElement('div');
    div.className = 'book';
    div.style.backgroundColor = "#f7e2b7";
    div.style.padding = "10px";
    div.style.marginBottom = "10px";
    div.style.borderRadius = "8px";
    div.style.boxShadow = "0 2px 4px rgba(0, 0, 0, 0.1)";

    div.innerHTML = `
      <img src="${book.thumbnail || ''}" alt="Cover">
      <div class="book-info">
        <div class="book-title">
          ${book.title}
          ${editMode ? `<button onclick="editBook(${index})" style="margin-left: 1rem;">‚úèÔ∏è</button>` : ''}
        </div>
        <div>${(book.authors || []).map(normalizeName).join('; ')}</div>
        ${book.series ? `<div><b>Serie:</b> ${book.series}</div>` : ''}
        ${book.volume ? `<div><b>Band:</b> ${book.volume}</div>` : ''}
        ${book.category ? `<div><b>Kategorie:</b> ${book.category}</div>` : ''}
        ${book.genre ? `<div><b>Genre:</b> ${book.genre}</div>` : ''}
        <div><b>ISBN:</b> ${book.isbn || 'Unbekannt'}</div>
        <div><b>Ver√∂ffentlicht:</b> ${book.publishedDate || 'Unbekannt'}</div>
        <div><b>Seitenanzahl:</b> ${book.pageCount || 'Unbekannt'}</div>
        <div><b>Gelesen:</b> ${book.read ? 'Ja' : 'Nein'}</div>
        ${book.rating ? `<div><b>Bewertung:</b> ${'‚òÖ'.repeat(book.rating)}${'‚òÜ'.repeat(5 - book.rating)}</div>` : ''}
        <div>${book.description || ''}</div>
        <button onclick="confirmRemoveBook(${index})">üóëÔ∏è Buch l√∂schen</button>
      </div>`;
    libraryDiv.appendChild(div);
  });
}

/* x f√ºr Suchfeld */
document.getElementById("clear-search").addEventListener("click", () => {
  document.getElementById("search-input").value = "";
  renderLibrary();
});

document.addEventListener("DOMContentLoaded", async () => {
    renderFilterBar();
    populateCategoryAndGenreDropdowns();

    const storedBooks = localStorage.getItem("epubLibrary");

    if (storedBooks) {
        books = JSON.parse(storedBooks);
    } else {
        try {
            const response = await fetch("/mylibrary/bibliothek.json");
            if (response.ok) {
                books = await response.json();
                saveLibrary(); // speichert sie direkt in localStorage
            } else {
                console.error("Fehler beim Laden der bibliothek.json von GitHub:", response.status);
                books = [];
            }
        } catch (error) {
            console.error("Netzwerkfehler beim Laden der bibliothek.json:", error);
            books = [];
        }
    }

// Alle Cover-URLs von HTTP auf HTTPS √§ndern
  books = books.map(book => {
    if (book.cover && book.cover.startsWith("http://books.google.com")) {
      book.cover = book.cover.replace("http://", "https://");
    }
    return book;
  });

    renderLibrary(); // zeigt die B√ºcher an
});


</script>
</body>
</html>
