<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Meine Bibliothek</title>
  <link rel="icon" href="favicon.png" type="image/png">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Roboto&display=swap">
  
<style>
  
/* --- BASIS: Farben, Layout, Schrift --- */
body {
  background-color: #121212;
  color: #e0e0e0;
  font-family: 'Roboto', sans-serif;
  margin: 2rem;
  font-size: 0.9rem;
}
h1, h3 {
  text-align: center;
  color: #ffffff;
}
#controls, #filters {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
  margin-bottom: 1.5rem;
  justify-content: center;
}
button, select, input[type="text"], textarea {
  background-color: #1e1e1e;
  color: #e0e0e0;
  border: 1px solid #333;
  border-radius: 5px;
  padding: 0.5rem 1rem;
}
button:hover, select:hover, input[type="text"]:hover, textarea:hover {
  background-color: #333;
}


/* --- BIBLIOTHEK + BUCHKARTEN --- */
#library {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
  gap: 0.5rem;
}
.book {
  background: #1e1e1e;
  padding: 1rem;
  border-radius: 8px;
  box-shadow: 0 0 10px rgba(0,0,0,0.5);
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 0.5rem;
}
.book img {
  width: 100px;
  height: 140px;
  object-fit: cover;
  border-radius: 5px;
}
.book-info {
  width: 100%;
  text-align: center;
}
.stars-display {
  color: #fbc02d;
  font-size: 1.2rem;
  margin-top: 0.3rem;
  text-align: center;
}
.tag {
  display: inline-block;
  background-color: #333;
  color: #e0e0e0;
  padding: 0.2rem 0.5rem;
  border-radius: 10px;
  font-size: 0.8rem;
  margin: 0.1rem;
}
.book.fade-out {
  opacity: 0;
  transition: opacity 0.5s ease-out;
}

/* --- FILTER & SUCHFELD --- */	    
.filter-bar {
  display: flex;
  flex-wrap: wrap;
  justify-content: center;
  gap: 0.3rem;
  margin-bottom: 1rem;
}
.filter-bar button.active {
  background-color: #007bff;
}
#filters {
  display: flex;
  flex-wrap: wrap;
  gap: 1rem;
  margin-bottom: 1.5rem;
  justify-content: center;
}
.filter-buttons {
  display: flex;
  gap: 0.5rem;
}
.filter-buttons button.active {
  background-color: #007bff;
  color: white;
}
#search-wrapper {
  display: flex;
  align-items: center;
  justify-content: center;
}
#search-input {
  width: 150px;
  background-color: #1e1e1e;
  color: #e0e0e0;
  border: 1px solid #333;
  border-radius: 5px;
  padding: 0.5rem;
}
#search-input:focus {
  outline: none;
  border-color: #007bff;
  box-shadow: 0 0 8px #007bff;
  background-color: #1a1a1a;
}
#clear-search {
  margin-left: -30px;
  cursor: pointer;
  color: #888;
}

/* --- DIALOG / FORMULAR --- */    
dialog {
  background: #1e1e1e;
  color: #e0e0e0;
  border: none;
  border-radius: 8px;
  padding: 1rem;
}
#edit-dialog form {
  display: flex;
  flex-direction: column;
  gap: 0.2rem;
  max-width: 450px;
  margin: auto;
}
#edit-dialog label {
  display: flex;
  flex-direction: column;
  font-size: 0.9rem;
  padding: 0.3rem 0.5rem;
  box-sizing: border-box;
}
#edit-dialog input[type="text"],
#edit-dialog textarea,
#edit-dialog select {
  width: 100%;
  padding: 0.4rem;
  background-color: #1e1e1e;
  color: #e0e0e0;
  border: 1px solid #333;
  border-radius: 5px;
  box-sizing: border-box;
}
#edit-dialog menu {
  display: flex;
  justify-content: flex-end;
  gap: 1rem;
  margin-top: 0.5rem;
}
.checkbox-inline {
  display: flex;
  align-items: center;
  gap: 0.5rem;
}
.rating-wrapper {
  display: flex;
  align-items: center;
  gap: 0.5rem;
  margin-top: 0.5rem;
}
.stars {
  display: flex;
  gap: 0.3rem;
  cursor: pointer;
  font-size: 1.3rem;
}
.stars span {
  color: #888;
  transition: color 0.2s;
}
.stars span.active {
  color: gold;
}

/* --- MODALE FENSTER --- */
.modal.hidden {
  display: none;
}
.modal {
  position: fixed;
  top: 0; left: 0;
  width: 100%; height: 100%;
  background-color: rgba(0, 0, 0, 0.7);
  display: flex;
  justify-content: center;
  align-items: center;
  z-index: 9999;
}
.modal-content {
  background-color: #1e1e1e;
  padding: 2rem;
  border-radius: 10px;
  max-width: 500px;
  width: 90%;
  max-height: 80vh;
  overflow-y: auto;
}
.modal-content label {
  display: block;
  margin-bottom: 0.5rem;
}
.modal-content input[type="checkbox"] {
  margin-right: 0.5rem;
}
.modal-content button {
  margin-top: 1rem;
}
.modal-content ul {
  list-style: none;
  padding: 0;
}
.modal-content ul li {
  padding: 0.3rem;
  cursor: pointer;
}
.modal-content ul li:hover {
  background-color: #333;
}

/* --- ANIMATION DETAILS --- */	
.details {
  max-height: 0;
  overflow: hidden;
  transition: max-height 1.5s ease, padding 0.5s ease;
  margin-top: 0.5rem;
}
.details.open {
  max-height: 1000px;
  padding-top: 0.5rem;
}
.detail-fields {
  text-align: center;
  margin-bottom: 0.5rem;
}
.detail-description {
  text-align: left;
}

/* --- DREIECK FÃœR DETAILBUTTON --- */
.toggle-button {
  display: inline-flex;
  align-items: center;
  gap: 0.3rem;
  cursor: pointer;
}
.toggle-button.open {
  background-color: #007bff;  
}
.toggle-button .triangle {
  display: inline-block;
  transition: transform 0.3s ease;
}
.toggle-button.open .triangle {
  transform: rotate(90deg);
}

/* --- Heller Modus --- */
body.light-mode {
  background-color: #f8f1e4;
  color: #2e2e2e;
}
body.light-mode h3 {
  color: #3b2f1c;
}
body.light-mode .book {
  background-color: #f5e6c1;
  color: #2e2e2e;
  box-shadow: 10px 10px 10px rgba(160, 120, 60, 0.2);
  border: 1px solid #caa66a;
}
body.light-mode .book-info,
body.light-mode .details {
  color: #2e2e2e;
}
body.light-mode .modal-content,
body.light-mode dialog,
body.light-mode input,
body.light-mode textarea,
body.light-mode select,
body.light-mode button {
  background-color: #f5e6c5;
  color: #2e2e2e;
  border: 1px solid #caa66a;
}
body.light-mode input[type="text"],
body.light-mode textarea {
  background-color: #fffaf0;
  color: #2e2e2e;
}
body.light-mode #search-input {
  background-color: #f5e6c1;
  color: #2e2e2e;
  border: 1px solid #caa66a;
}
body.light-mode #search-input:focus {
  border-color: #c28f49;
  box-shadow: 0 0 8px #c28f49;
  background-color: #fff3dd;
}
body.light-mode .filter-bar button.active,
body.light-mode #filters button.active {
  background-color: #c28f49;
  color: white;
}
body.light-mode .toggle-button.open {
  background-color: #c28f49;
}
body.light-mode #edit-dialog label {
  padding: 0.3rem 0.5rem;
}
body.light-mode #edit-dialog input[type="text"],
body.light-mode #edit-dialog textarea,
body.light-mode #edit-dialog select {
  background-color: #fffaf0;
  color: #2e2e2e;
  border: 1px solid #caa66a;
}
body.light-mode .stars-display {
  color: #c28f00;
}
body.light-mode .stars span.active {
  color: #f5a527;
}
body.light-mode .modal-content ul li:hover {
  background-color: #e0d5b8;
  color: #2e2e2e;
}

/* Wrapper fÃ¼r beide Buttons */
#top-buttons {
  position: fixed;
  top: 1rem;
  right: 1rem;
  display: flex;
  gap: 0.5rem;
  z-index: 10000;
}

/* Gemeinsames Styling */
#top-buttons button {
  font-size: 0.8rem;
  border: none;
  border-radius: 20px;
  padding: 0.3rem 1rem;
  cursor: pointer;
}

/* Dunkelmodus */
body.dark-mode #top-buttons button {
  background-color: #333;
  color: #fff;
}
body.dark-mode #top-buttons button:hover {
  background-color: #555;
}

/* Hellmodus */
body.light-mode #top-buttons button {
  background-color: #caa66a;
  color: #2e2e2e;
}
body.light-mode #top-buttons button:hover {
  background-color: #d7b77a;
}


/* --- Benachrichtung --*/
#toast {
  visibility: hidden;
  min-width: 250px;
  margin-left: -125px;
  background-color: #333;
  color: #fff;
  text-align: center;
  border-radius: 6px;
  padding: 16px;
  position: fixed;
  z-index: 9999;
  left: 50%;
  bottom: 30px;
  font-size: 16px;
  opacity: 0;
  transition: opacity 0.5s ease, bottom 0.5s ease;
}
#toast.show {
  visibility: visible;
  opacity: 1;
  bottom: 50px;
}

/* --- Umschalter --*/
.toggle-container {
  display: flex;
  align-items: center;
  gap: 10px;
  margin-top: 10px;
}

.toggle-label {
  font-size: 0.9em;
  color: var(--text-color);
}

.toggle-switch {
  position: relative;
  display: inline-block;
  width: 46px;
  height: 24px;
}

.toggle-switch input {
  opacity: 0;
  width: 0;
  height: 0;
}

.slider {
  position: absolute;
  cursor: pointer;
  top: 0; left: 0; right: 0; bottom: 0;
  background-color: #ccc;
  border-radius: 24px;
  transition: 0.4s;
}

.slider:before {
  content: "";
  position: absolute;
  height: 18px;
  width: 18px;
  left: 3px;
  bottom: 3px;
  background-color: white;
  border-radius: 50%;
  transition: 0.4s;
}

.toggle-switch input:checked + .slider {
  background-color: var(--accent-color, #4CAF50);
}

.toggle-switch input:checked + .slider:before {
  transform: translateX(22px);
}

/* Standardansicht (Detailansicht) */
#library {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(200x, 1fr));
  gap: 1rem;
}

/* Kompaktansicht */
body.compact-view #library {
  grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
  gap: 0.5rem;
}

body.compact-view .book {
  padding: 0.3rem;
  margin: 0;
  width: 100%;
}

body.compact-view .book img {
  width: 80px;
  height: 110px;
}

/* Nur Titel + Autor anzeigen */
body.compact-view .book-info > *:not(.book-title):not(:nth-of-type(2)) {
  display: none;
}

body.compact-view .book-title {
  
  font-size: 0.8rem;
  margin: 0.2rem 0;
}

</style>
</head>

<body>

<h3>ğŸ“š Meine Bibliothek</h3>
<div id="read-counter" style="text-align:center; margin-bottom:1rem; font-size: 1.1rem;"></div>
<div id="top-buttons">
  <button id="viewToggleBtn" onclick="toggleViewMode()">ğŸ”¼</button>
  <button id="mode-toggle" onclick="toggleMode()">ğŸŒ™</button>
</div>

<div id="controls">
  <input type="file" id="file-input" accept=".epub" multiple hidden>
  <input type="file" id="load-file" accept=".json" hidden>
</div>

<!-- Filter Status, Kategorie, Genre, Suche -->
<div id="filters" class="filter-toolbar">
  <div class="filter-group">
    <button id="all-btn" onclick="setFilterStatus('all')">ğŸ“š Alle</button>
    <button id="read-btn" onclick="setFilterStatus('read')">ğŸ“– Gelesen</button>
    <button id="unread-btn" onclick="setFilterStatus('unread')">ğŸ†• Neu</button>
  </div>

  <div class="filter-group">
    <button id="category-button" onclick="openCategorySelector()">Kategorie filtern</button>
    <button id="genre-button" onclick="openGenreSelector()">Genre filtern</button>
  </div>

  <div class="filter-group search-group">
    <input type="text" id="search-input" placeholder="ğŸ” Suchen...">
    <span id="clear-search" onclick="clearSearch()">Ã—</span>
  </div>
</div>


<!-- Filterleiste A-Z -->
<div class="filter-bar" id="filter-bar"></div>

<!-- Modal zur Kategorieauswahl -->
<div id="category-modal" class="modal hidden">
  <div class="modal-content">
    <h3>Kategorie auswÃ¤hlen</h3>
    <ul id="category-list"></ul>
    <button onclick="closeCategorySelector()">Abbrechen</button>
  </div>
</div>

<!-- Modal zur Genre-Auswahl -->
<div id="genre-modal" class="modal hidden">
  <div class="modal-content">
    <h3>Genres auswÃ¤hlen</h3>
    <form id="genre-form"></form>
	<div class="toggle-container">
	 <label class="toggle-switch">
      <input type="checkbox" id="genreMatchToggle">
      <span class="slider"></span>
	 </label>
	 <span class="toggle-label">Alle gewÃ¤hlten Genres mÃ¼ssen enthalten sein</span>
	</div>
    <button onclick="applyGenreSelection()">OK</button>
    <button onclick="closeGenreSelector()" type="button">Abbrechen</button>
  </div>
</div>

<div id="library"></div>

<!-- Dialog fÃ¼r Buch hinzufÃ¼gen/bearbeiten -->
<dialog id="edit-dialog">
  <form method="dialog" id="edit-form">
    <h3>Buch bearbeiten oder hinzufÃ¼gen</h3>
    <input type="hidden" id="edit-index">
    <label>Titel: <input type="text" id="edit-title" required></label>
    <label>Autor(en) (Nachname, Vorname â€“ Semikolon-getrennt): <input type="text" id="edit-authors" required></label>
    <label>Serie: <input type="text" id="edit-series"></label>
    <label>Band: <input type="text" id="edit-volume"></label>
    <label>VerÃ¶ffentlicht: <input type="text" id="edit-publishedDate"></label>
    <label>ISBN: <input type="text" id="edit-isbn"></label>
    <label>Kategorie: <input type="text" id="edit-category" list="categorySuggestions"></label>
    <label>Genre: <input type="text" id="edit-genre" list="genreSuggestions"></label>
    <label>Beschreibung: <textarea id="edit-description" rows="4"></textarea></label>
    <label>Seitenzahl: <input type="text" id="edit-pageCount"></label>
    <label>Cover-URL: <input type="text" id="edit-thumbnail"></label>
    <div class="checkbox-inline">
      <input type="checkbox" id="edit-read"> <label for="edit-read">ğŸ“— Gelesen</label>
    </div>
    <div class="rating-wrapper">
      <span>Bewertung:</span>
      <div id="edit-rating" class="stars" data-value="0">
        <span data-star="1">â˜†</span>
        <span data-star="2">â˜†</span>
        <span data-star="3">â˜†</span>
        <span data-star="4">â˜†</span>
        <span data-star="5">â˜†</span>
      </div>
    </div>
	<label>SchlagwÃ¶rter (kommagetrennt):
	  <input type="text" id="edit-tags" placeholder="z.â€¯B. Land, Holocaust, Dystopie">
	</label>
    <menu style="display:flex; justify-content: flex-end; gap:1rem; margin-top:1rem;">
      <button type="submit">ğŸ“… Speichern</button>
      <button type="reset" onclick="document.getElementById('edit-dialog').close()">Abbrechen</button>
    </menu>
  </form>
</dialog>

<!-- Datalist VorschlÃ¤ge -->
<datalist id="categorySuggestions"></datalist>
<datalist id="genreSuggestions"></datalist>

<script src="https://unpkg.com/jszip/dist/jszip.min.js"></script>
<script>
const genreMap = {
  "Belletristik": ["Erotik", "Fantasy", "Frauen, Liebesroman", "Historisch", "Horror", "Humor", "Kinder, Jugend", "Klassiker", "Krimi & Thriller", "Mystery", "Romane & ErzÃ¤hlungen", "Science Fiction"],
  "Ratgeber": ["Beruf", "Freizeit", "LebensfÃ¼hrung"],
  "Sachbuch": ["Biografien & Erinnerungen", "Geschichte", "Gesundheit & Medizin", "Kunst", "Mathematik", "Naturwissenschaft", "Philosophie", "Politik", "Psychologie", "Reisen"],
};

// Genre 'Und' - 'Oder'
let genreMatchMode = "any";

// Vorschlagsliste fÃ¼r Kategorie im Formular befÃ¼llen
function populateCategorySuggestions() {
  const categoryList = document.getElementById("categorySuggestions");
  categoryList.innerHTML = '';

  Object.keys(genreMap).forEach(cat => {
    const option = document.createElement("option");
    option.value = cat;
    categoryList.appendChild(option);
  });
}

// Beim Laden einmal aufrufen
document.addEventListener("DOMContentLoaded", () => {
  populateCategorySuggestions();
});

function filterByCategory(category) {
  if (selectedCategories[0] === category) {
    // Filter aufheben
    selectedCategories = [];
    document.getElementById("category-button").textContent = "Kategorie filtern";
  } else {
    // Neue Kategorie setzen
    selectedCategories = [category];
    document.getElementById("category-button").textContent = category;
  }

  // Genre-Filter zurÃ¼cksetzen
  selectedGenres = [];
  document.getElementById("genre-button").textContent = "Genre filtern";

  renderLibrary();
}


// Ã–ffnet das Kategorie-Auswahlfenster
function openCategorySelector() {
  const list = document.getElementById("category-list");
  list.innerHTML = '';
  Object.keys(genreMap).forEach(cat => {
    const li = document.createElement("li");
    li.textContent = cat;
    li.onclick = () => {
  filterByCategory(cat);
  closeCategorySelector();
};
    list.appendChild(li);
  });
  document.getElementById("category-modal").classList.remove("hidden");
}

// Schliesst das Kategorie-Auswahlfenster
function closeCategorySelector() {
  document.getElementById("category-modal").classList.add("hidden");
}

// Ã–ffnet das Genre-Auswahlfenster mit Checkboxen
function openGenreSelector() {
  const form = document.getElementById("genre-form");
  form.innerHTML = '';

  const selectedCategory = selectedCategories[0];
  const genres = genreMap[selectedCategory] || [];

  genres.forEach(gen => {
    const label = document.createElement("label");
    const checkbox = document.createElement("input");
    checkbox.type = "checkbox";
    checkbox.value = gen;
    checkbox.name = "genre";
    checkbox.checked = selectedGenres.includes(gen);
    label.appendChild(checkbox);
    label.append(" ", gen);
    form.appendChild(label);
  });

  document.getElementById("genre-modal").classList.remove("hidden");
}



// Schliesst das Genre-Auswahlfenster
function closeGenreSelector() {
  document.getElementById("genre-modal").classList.add("hidden");
}

// Wendet die Genre-Filterauswahl an
function applyGenreSelection() {
  const form = document.getElementById("genre-form");
  const checked = [...form.elements["genre"]].filter(input => input.checked).map(input => input.value);
  selectedGenres = checked;
  document.getElementById("genre-button").textContent = selectedGenres.length > 0 ? selectedGenres.join(', ') : 'Genre filtern';
  closeGenreSelector();
  renderLibrary();
}

// --- ZustÃ¤nde ---
let selectedCategories = [];
let selectedGenres = [];

let library = JSON.parse(localStorage.getItem('epubLibrary') || '[]');
let editMode = false;
let activeFilters = [];
let isCreatingNew = false;
let filterStatus = 'all'; // 'all', 'read', 'unread'


// Hilfsfunktionen
function normalizeName(name) {
  return name
    .trim()
    .replace(/,+/g, ',')
    .replace(/\s*,\s*/g, ', ')
    .replace(/\s*;\s*/g, '; ')
    .replace(/^;+|;+$|^,+|,+$/g, '')
    .split(';')
    .map(part => part.trim())
    .filter(Boolean)
    .join('; ');
}

function normalizeFirstLetter(name) {
  return normalizeName(name).charAt(0).toUpperCase().normalize("NFD").replace(/[\u0300-\u036f]/g, '');
}


// Suchfeld lÃ¶schen
document.addEventListener("DOMContentLoaded", () => {
  const searchInput = document.getElementById("search-input");
  const clearBtn = document.getElementById("clear-search");

  if (searchInput) {
    searchInput.addEventListener("input", () => {
      renderLibrary();
    });

// Enter-Taste leeren
    searchInput.addEventListener("keydown", (event) => {
      if (event.key === "Enter") {
        event.preventDefault();
        event.target.value = "";
        renderLibrary();
      }
    });
  }

  if (clearBtn) {
    clearBtn.addEventListener("click", () => {
      searchInput.value = "";
      renderLibrary();
    });
  }  
});


// --- Initialisierung ---
document.addEventListener("DOMContentLoaded", () => {
  renderFilterBar();
  renderLibrary();
});

// Hilfsfunktionen
function normalizeName(name) {
  return name
    .trim()
    .replace(/,+/g, ',')
    .replace(/\s*,\s*/g, ', ')
    .replace(/\s*;\s*/g, '; ')
    .replace(/^;+|;+$|^,+|,+$/g, '')
    .split(';')
    .map(part => part.trim())
    .filter(Boolean)
    .join('; ');
}

function normalizeFirstLetter(name) {
  return normalizeName(name).charAt(0).toUpperCase();
}

// --- Filterleiste A-Z ---
function renderFilterBar() {
  const filterBar = document.getElementById("filter-bar");
  filterBar.innerHTML = '';

  for (let i = 65; i <= 90; i++) {
    const char = String.fromCharCode(i);
    const btn = document.createElement("button");
    btn.textContent = char;

    btn.onclick = () => {
      if (activeFilters.includes(char)) {
        activeFilters = activeFilters.filter(l => l !== char);
      } else {
        activeFilters.push(char);
      }
      renderLibrary();
    };

    if (activeFilters.includes(char)) {
      btn.classList.add("active");
    }
    filterBar.appendChild(btn);
  }
}

// --- Bibliothek rendern ---
function renderLibrary() {
  renderFilterBar();
  const libraryDiv = document.getElementById("library");
  libraryDiv.innerHTML = '';
  let books = [...library];

// Filter anwenden
  if (selectedCategories.length > 0) {
    books = books.filter(book => selectedCategories.includes(book.category));
  }
  if (selectedGenres.length > 0) {
  books = books.filter(book => {
    const bookGenres = (book.genre || "").split(";").map(g => g.trim().toLowerCase());
    const selected = selectedGenres.map(g => g.toLowerCase());

    if (genreMatchMode === "all") {
      return selected.every(sel => bookGenres.includes(sel));
    } else {
      return selected.some(sel => bookGenres.includes(sel));
    }
  });
}
  const searchTerm = document.getElementById("search-input").value.trim().toLowerCase();
if (searchTerm) {
  books = books.filter(book =>
    (book.title || '').toLowerCase().includes(searchTerm) ||
    (book.authors || []).join('; ').toLowerCase().includes(searchTerm) ||
    (book.series || '').toLowerCase().includes(searchTerm) ||
    (book.tags || []).some(tag => tag.toLowerCase().includes(searchTerm))
  );
}
  if (filterStatus === 'read') {
    books = books.filter(book => book.read === true);
  } else if (filterStatus === 'unread') {
    books = books.filter(book => book.read !== true);
  }
  if (activeFilters.length > 0) {
    books = books.filter(book =>
      (book.authors || []).some(author =>
        activeFilters.includes(normalizeFirstLetter(author))
      )
    );
  }
  
  
// Sortierung
  books.sort((a, b) => {
    const aStr = `${normalizeName(a.authors?.[0] || '')} - ${a.series || ''} - ${a.volume || ''} - ${a.title}`;
    const bStr = `${normalizeName(b.authors?.[0] || '')} - ${b.series || ''} - ${b.volume || ''} - ${b.title}`;
    return aStr.localeCompare(bStr, 'de');
  });

// Ausgabe
  books.forEach(book => {
    const index = library.indexOf(book);
    const div = document.createElement('div');
    div.className = 'book';

    div.innerHTML = `
      <img src="${book.thumbnail || ''}" alt="Cover">
      <div class="book-info">
        <div class="book-title">${book.title}</div>
        <div>${(book.authors || []).map(normalizeName).join('; ')}</div>
        ${book.series ? `<div><b>Serie:</b> ${book.series}</div>` : ''}
        ${book.volume ? `<div><b>Band:</b> ${book.volume}</div>` : ''}
        ${book.category ? `<div><b>Kategorie:</b> ${book.category}</div>` : ''}
        ${book.genre ? `<div><b>Genre:</b> ${book.genre}</div>` : ''}
        <div><b>Status:</b> <span style="color: ${book.read ? '#3feb57' : '#00bfff'};">
          ${book.read ? 'ğŸ“— Gelesen' : 'ğŸ†• Ungelesen'}</span>
        </div>
        ${book.rating ? `
          <div class="stars-display" title="${book.rating} von 5 Sternen">
            ${'â˜…'.repeat(book.rating)}${'â˜†'.repeat(5 - book.rating)}
          </div>
        ` : ''}

        <div class="book-actions">
          <button class="toggle-button" onclick="toggleDetails(this)">
            <span class="triangle">â–¶ï¸</span>
          </button>
         
        </div>

        <div class="details">
          <div style="text-align: center;">
            <div><b>ISBN:</b> ${book.isbn || 'Unbekannt'}</div>
            <div><b>VerÃ¶ffentlicht:</b> ${book.publishedDate || 'Unbekannt'}</div>
            <div><b>Seitenzahl:</b> ${book.pageCount || 'Unbekannt'}</div>
          </div>
          <div style="margin-top: 0.5rem;">${book.description || ''}</div>
		  ${book.tags && book.tags.length > 0
			? `<div><b>Tags:</b> ${book.tags.map(tag => `<span class="tag">${tag}</span>`).join(' ')}</div>`
			: ''}
        </div>
      </div>
    `;

    libraryDiv.appendChild(div);updateReadCounter();

  });
}



// Interaktive Sternebewertung (fÃ¼r das Formular)
function setupStarRating() {
  const ratingDiv = document.getElementById("edit-rating");
  if (!ratingDiv) return;

  const stars = ratingDiv.querySelectorAll("span");

  stars.forEach(star => {
    star.addEventListener("click", () => {
      const value = parseInt(star.getAttribute("data-star"));
      ratingDiv.setAttribute("data-value", value);
      updateStarDisplay(ratingDiv, value);
    });
  });
}

// Aktualisiert visuelle Darstellung der aktiven Sterne
function updateStarDisplay(container, value) {
  const stars = container.querySelectorAll("span");
  stars.forEach(star => {
    const starVal = parseInt(star.getAttribute("data-star"));
    star.classList.toggle("active", starVal <= value);
  });
}

function editBook(index) {
  const book = library[index];
  isCreatingNew = false;
  document.getElementById("edit-index").value = index;
  document.getElementById("edit-title").value = book.title || '';
  document.getElementById("edit-authors").value = (book.authors || []).join('; ');
  document.getElementById("edit-series").value = book.series || '';
  document.getElementById("edit-volume").value = book.volume || '';
  document.getElementById("edit-publishedDate").value = book.publishedDate || '';
  document.getElementById("edit-isbn").value = book.isbn || '';
  document.getElementById("edit-category").value = book.category || '';
  document.getElementById("edit-genre").value = book.genre || '';
  document.getElementById("edit-description").value = book.description || '';
  document.getElementById("edit-pageCount").value = book.pageCount || '';
  document.getElementById("edit-thumbnail").value = book.thumbnail || '';
  document.getElementById("edit-read").checked = book.read || false;
  document.getElementById("edit-tags").value = (book.tags || []).join(', ');


  // Genre-VorschlÃ¤ge abhÃ¤ngig von der gewÃ¤hlten Kategorie aktualisieren
  const selectedCategory = book.category;
  const genreList = document.getElementById("genreSuggestions");
  genreList.innerHTML = '';
  if (genreMap[selectedCategory]) {
    genreMap[selectedCategory].forEach(genre => {
      const option = document.createElement("option");
      option.value = genre;
      genreList.appendChild(option);
    });
  }

  document.getElementById("edit-dialog").showModal();
  updateStarDisplay(document.getElementById("edit-rating"), book.rating || 0);
  document.getElementById("edit-rating").setAttribute("data-value", book.rating || 0);
}


// --- Buch speichern (Neues oder Bearbeitetes) ---
document.getElementById("edit-form").addEventListener("submit", () => {
  const index = document.getElementById("edit-index").value;
  const authorsRaw = document.getElementById("edit-authors").value;
  const book = {
    title: document.getElementById("edit-title").value.trim(),
    authors: authorsRaw.split(';').map(a => normalizeName(a.trim())).filter(Boolean),
    series: document.getElementById("edit-series").value.trim(),
    volume: document.getElementById("edit-volume").value.trim(),
    publishedDate: document.getElementById("edit-publishedDate").value.trim(),
    isbn: document.getElementById("edit-isbn").value.trim(),
    category: document.getElementById("edit-category").value.trim(),
    genre: document.getElementById("edit-genre").value.trim(),
    description: document.getElementById("edit-description").value.trim(),
    pageCount: document.getElementById("edit-pageCount").value.trim(),
    thumbnail: document.getElementById("edit-thumbnail").value.trim(),
    read: document.getElementById("edit-read").checked,
	rating: parseInt(document.getElementById("edit-rating").getAttribute("data-value")) || null,
	tags: document.getElementById("edit-tags").value
	  .split(',')
	  .map(tag => tag.trim())
	  .filter(Boolean),


  };

  if (index !== '' && !isCreatingNew) {
    library[+index] = { ...library[+index], ...book };
  } else {
    library.push(book);
  }

  localStorage.setItem("epubLibrary", JSON.stringify(library));
  document.getElementById("edit-dialog").close();
  renderLibrary();
});

// --- BÃ¼cher aus .epub Dateien importieren ---
async function processFile(file) {
  const zip = await JSZip.loadAsync(file);
  const container = await zip.file("META-INF/container.xml").async("string");
  const parser = new DOMParser();
  const containerDoc = parser.parseFromString(container, "application/xml");
  const rootfilePath = containerDoc.querySelector("rootfile")?.getAttribute("full-path");
  if (!rootfilePath) return;

  const contentOpf = await zip.file(rootfilePath).async("string");
  const opfDoc = parser.parseFromString(contentOpf, "application/xml");

  let title = opfDoc.querySelector("metadata > title")?.textContent || file.name.replace(/\.epub$/i, '');
  let authors = Array.from(opfDoc.querySelectorAll("metadata > creator")).map(el => el.textContent.trim());

  let rawIsbn = Array.from(opfDoc.querySelectorAll("metadata > identifier"))
    .map(el => el.textContent)
    .find(id => id.replace(/[^0-9X]/gi, "").length >= 10) || "";

  const cleanIsbn = rawIsbn.replace(/[^0-9X]/gi, '');

  if (library.some(book => (book.isbn || "").replace(/[^0-9X]/gi, '') === cleanIsbn)) {
    console.log(`Buch mit ISBN ${cleanIsbn} existiert bereits.`);
    return;
  }

  const book = {
    title,
    authors,
    isbn: cleanIsbn,
    series: "",
    volume: "",
    publishedDate: "",
    description: "",
    thumbnail: "",
    read: false,
    pageCount: ""
  };

  // Serie und Bandnummer aus OPF lesen
  const metaTags = opfDoc.querySelectorAll("metadata > meta");
  metaTags.forEach(meta => {
    const name = meta.getAttribute("name");
    const content = meta.getAttribute("content");
    if (name === "calibre:series") {
      book.series = content;
    } else if (name === "calibre:series_index") {
      book.volume = content;
    }
  });

  if (cleanIsbn) {
    try {
      const response = await fetch(`https://www.googleapis.com/books/v1/volumes?q=isbn:${cleanIsbn}&key=${apiKey}`);
      const data = await response.json();
      const info = data.items?.[0]?.volumeInfo;
      if (info) {
        const subtitle = info.subtitle?.trim();
        book.title = subtitle ? `${info.title}. ${subtitle}` : info.title || book.title;

        book.authors = info.authors ? info.authors.map(author => {
          const parts = author.trim().split(/\s+/);
          if (parts.length >= 2) {
            const last = parts.pop();
            const first = parts.join(' ');
            return `${last}, ${first}`;
          }
          return author.trim();
        }) : book.authors;

        book.publishedDate = info.publishedDate || "";
        book.description = info.description || "";
        book.thumbnail = info.imageLinks?.thumbnail?.replace("http:", "https:") || "";
        book.pageCount = info.pageCount ? info.pageCount.toString() : "Unbekannt";

        if (!book.thumbnail) {
          console.warn(`Kein Cover fÃ¼r ISBN ${cleanIsbn} gefunden.`);
        }
      } else {
        console.warn(`Keine Google Books Info fÃ¼r ISBN ${cleanIsbn} gefunden.`);
      }
    } catch (e) {
      console.error("Fehler bei der Google API:", e);
    }
  } else {
    console.warn(`Keine gÃ¼ltige ISBN in der Datei ${file.name} gefunden.`);
  }

  library.push(book);
  showToast(`â€${book.title}â€œ wurde importiert.`);
}


// --- Funktionen fÃ¼r Suche, Clear Button und initiales Laden ---
function clearSearch() {
  document.getElementById("search-input").value = "";
  renderLibrary();
}

document.getElementById("search-input").addEventListener("input", () => {
  renderLibrary();
});

function openImport() {
  document.getElementById("file-input").click();
}

function openLoadLibrary() {
  document.getElementById("load-file").click();
}

document.getElementById("file-input").addEventListener("change", async (e) => {
  const files = Array.from(e.target.files);
  for (const file of files) {
    await processFile(file);
  }
  localStorage.setItem("epubLibrary", JSON.stringify(library));
  renderLibrary();
});

document.getElementById("load-file").addEventListener("change", async (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const text = await file.text();
  try {
    const json = JSON.parse(text);
    if (Array.isArray(json)) {
      library = json;
      localStorage.setItem("epubLibrary", JSON.stringify(library));
      renderLibrary();
    } else {
      showToast("UngÃ¼ltiges Format");
    }
  } catch (err) {
    showToast("Fehler beim Laden der Datei");
  }
});

// Alle/Oder Genreschalter
document.getElementById("genreMatchToggle").addEventListener("change", function () {
  genreMatchMode = this.checked ? "all" : "any";
  renderLibrary();
});


// Dynamische Genre-VorschlÃ¤ge je nach Kategorie im Formular
document.getElementById("edit-category").addEventListener("input", () => {
  const selectedCategory = document.getElementById("edit-category").value;
  const genreList = document.getElementById("genreSuggestions");

  // Genre-Liste leeren
  genreList.innerHTML = '';

  // Neue VorschlÃ¤ge je nach Kategorie aus genreMap einfÃ¼gen
  const genres = genreMap[selectedCategory] || [];
  genres.forEach(genre => {
    const option = document.createElement("option");
    option.value = genre;
    genreList.appendChild(option);
  });

  // Wenn der aktuelle Genre-Wert nicht mehr zur Kategorie passt â†’ lÃ¶schen
  const currentGenre = document.getElementById("edit-genre").value;
  if (!genres.includes(currentGenre)) {
    document.getElementById("edit-genre").value = '';
  }
});


// Seite initial laden
document.addEventListener("DOMContentLoaded", () => {
  renderFilterBar();
  renderLibrary();
});

function formatAuthors(authors) {
  return authors.map(name => {
    name = name.trim();
    if (name.includes(',')) {
      const [last, first] = name.split(',').map(s => s.trim());
      return `${last}, ${first}`;
    } else {
      const parts = name.split(/\s+/);
      if (parts.length >= 2) {
        const firstName = parts.slice(0, -1).join(' ');
        const lastName = parts.slice(-1)[0];
        return `${lastName}, ${firstName}`;
      }
      return name;
    }
  });
}

// Alle, Gelesen, Neu aktiv
function setFilterStatus(status) {
  filterStatus = status;
  renderLibrary();

  document.getElementById('all-btn').classList.remove('active');
  document.getElementById('read-btn').classList.remove('active');
  document.getElementById('unread-btn').classList.remove('active');

  if (status === 'all') {
    document.getElementById('all-btn').classList.add('active');
  } else if (status === 'read') {
    document.getElementById('read-btn').classList.add('active');
  } else if (status === 'unread') {
    document.getElementById('unread-btn').classList.add('active');
  }
}

// Details slowly
function toggleDetails(button) {
  const detailsDiv = button.parentElement.nextElementSibling;
  detailsDiv.classList.toggle('open');
  button.classList.toggle('open');
}

setupStarRating();

function confirmRemoveBook(index) {
  const book = library[index];
  const title = book.title || 'dieses Buch';
  if (confirm(`MÃ¶chtest du "${title}" wirklich lÃ¶schen?`)) {
    removeBook(index);
  }
}

function removeBook(index) {
  const book = library[index];
  const libraryDiv = document.getElementById("library");
  const bookDivs = libraryDiv.querySelectorAll(".book");
  const bookDiv = bookDivs[index];

  if (bookDiv) {
    bookDiv.classList.add("fade-out");
    setTimeout(() => {
      library.splice(index, 1);
      localStorage.setItem("epubLibrary", JSON.stringify(library));
      renderLibrary(); // Nach dem Fade-out neu rendern
    }, 500); // Zeit passend zum CSS transition delay
  } else {
    // Fallback â€“ falls das Buch nicht gefunden wird
    library.splice(index, 1);
    localStorage.setItem("epubLibrary", JSON.stringify(library));
    renderLibrary();
  }
}

function updateReadCounter() {
  const count = library.filter(book => book.read === true).length;
  const total = library.length;
  const counter = document.getElementById("read-counter");
  if (counter) {
    counter.textContent = `ğŸ“— Gelesen: ${count} von ${total} BÃ¼chern`;
  }
}

function toggleMode() {
  const body = document.body;
  const isLight = body.classList.toggle('light-mode');
  localStorage.setItem('library-mode', isLight ? 'light' : 'dark');
  document.getElementById("mode-toggle").textContent = isLight ? "ğŸŒ" : "ğŸŒ™";
}

function showToast(message, duration = 3000) {
  let toast = document.getElementById("toast");
  if (!toast) {
    toast = document.createElement("div");
    toast.id = "toast";
    document.body.appendChild(toast);
  }
  toast.textContent = message;
  toast.className = "show";
  setTimeout(() => {
    toast.className = toast.className.replace("show", "");
  }, duration);
}

// Kompaktansicht
let compactViewEnabled = false;

function toggleViewMode() {
  compactViewEnabled = !compactViewEnabled;
  const toggleButton = document.getElementById("viewToggleBtn");
  document.body.classList.toggle("compact-view", compactViewEnabled);
  toggleButton.textContent = compactViewEnabled ? "ğŸ”½" : "ğŸ”¼";

  // Speichern des Modus
  localStorage.setItem('library-view', compactViewEnabled ? 'compact' : 'detail');
}

// Beim Laden schauen, was gespeichert wurde
document.addEventListener("DOMContentLoaded", () => {
  const saved = localStorage.getItem('library-mode');
  if (saved === 'light') {
    document.body.classList.add('light-mode');
    document.getElementById("mode-toggle").textContent = "ğŸŒ";
  }

  // Kompaktansicht wiederherstellen
  const view = localStorage.getItem('library-view');
  if (view === 'compact') {
    compactViewEnabled = false; // damit toggle korrekt funktioniert
    toggleViewMode();
  }
});

let books = [];

document.addEventListener("DOMContentLoaded", async () => {
  renderFilterBar();
  
  const storedBooks = localStorage.getItem("epubLibrary");

  if (storedBooks) {
    books = JSON.parse(storedBooks);
  } else {
    try {
      const response = await fetch("https://takasila.github.io/mylibrary/bibliothek.json");
      if (response.ok) {
        books = await response.json();
        localStorage.setItem("epubLibrary", JSON.stringify(books));
      } else {
        console.error("Fehler beim Laden der bibliothek.json von GitHub:", response.status);
        books = [];
      }
    } catch (error) {
      console.error("Netzwerkfehler beim Laden der bibliothek.json:", error);
      books = [];
    }
  }

  renderLibrary();
});


</script>

</body>
</html>
